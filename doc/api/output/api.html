<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Hashspace — API Doc </title>
	<style>
body {
    font-family: Helvetica;
    color: rgba(0, 0, 0, 0.85);
    margin: auto;
    width: 21cm;

    border-right: solid gray 1px;
    border-left: solid gray 1px;
    border-radius: 0.5em;
    padding: 2em;
    margin-top: 5px;
    box-shadow: 0px -5px 10px black;
}


pre {
    border: inset 1px black;
    border-radius: 1em;
    padding-left: 1em;
    background-color: #f8f8f8;
    font-family: Consolas;
}

code {
    border: solid 0.5px gray;
    border-radius: 3px;
    padding: 1px;
    background-color: #f8f8f8;
    position: relative;
    top: -1px;
}

pre > code {
    border: none;
    background-color: transparent;
}



hr {
    /*background-color: gray;*/
    background-color: rgba(0, 0, 255, 0.1);
    border: solid gray 0px;
    border-radius: 1em;
    height: 1em;
}

	</style>
</head>
<body>
	<hr />
	<section>
		<h3 id="_-template">
			# template - Statement
		</h3>
<p>
	<p><code># template name(parameters)</code> ... <code># /template</code> is used to define a template.</p>
		
</p>
<p>
	<p>A template has the following properties:</p>
		<ul>
		<li><strong>a name</strong>: the name of the reference to the template; works as any variable</li>
		<li><strong>formal parameters</strong>: a list of names for formal parameters. From the template, the names are used as references to the actual parameters. From the outside, actual parameters can be given <strong>by both position and name</strong>, depending on how the template is instantiated! Keep this in mind when defining your template.</li>
		</ul>
		<p>For reminder, a template is finally compiled by the engine and converted to a function, which returns a template instance bound to the given parameters when it gets called.</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
# template hello(who)
	Hello {who}!
# /template

var instance = hello("World");
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="template_render_domelementid_">
			template.render(DOMElementId) - Core
		</h3>
<p>
	<p>Renders a template instance into the DOM element corresponding to the given id.</p>
		
</p>
<p>
	
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
# template hello(who)
	Hello {who}!
# /template

hello("World").render("output");
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="_-export-template-name">
			# export template name - Statement
		</h3>
<p>
	<p>Exports a template in the current module.</p>
		
</p>
<p>
	<p>The export feature is something provided by the CommonJS implementation on which hashspace relies.</p>
		<p>The latter has a JavaScript API in order to export a value in a module.</p>
		<p>However the template statement provides a shortcut to export a template under a property corresponding to its given name, which is to put <code>export</code> at the very beginning of the statement, after the hash character.</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
# export template example()
	...
# /template
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="__subtemplatereference-__">
			<#subTemplateReference /> - Statement
		</h3>
<p>
	<p>Instantiates a template and outputs it at the place of the statement.</p>
		
</p>
<p>
	<p>Full syntax looks like this: <code>&lt;#subTemplateReference param1=&quot;param1Value param2=&quot;param2Value&quot;/&gt;</code> or <code>&lt;#subTemplateReference param1=&quot;param1Value param2=&quot;param2Value&quot;&gt; ... &lt;/#subTemplateReference&gt;</code>.</p>
		<p>It is intended to look like a standard HTML element in use: it is an element with a name and attributes, that can be used both in inline and block forms. This means mainly two important things:</p>
		<ul>
		<li>parameters of the template (attributes) are passed by name, not by position</li>
		<li>it not only instantiates the template but also renders it automatically in a DOM element inserted exactly where the statement is used</li>
		</ul>
		<p>There is however a little difference which makes the feature far more powerful: the statement is not expecting a simple template name, it takes a reference to it through an expression. Since this is an expression, its follows the binding rules. This means that you can change the referenced value at some point, and the parent template will get refreshed thanks to the binding, using the new subtemplate thanks to the reference.</p>
		<p>Please note that attributes/parameters will also follow the usual binding rules.</p>
		<p>Last but not least: you will use the block form of the statement only if you have to pass <code>template</code> attributes&#39; values to the subtemplate. See <a href="#template">corresponding section</a>.</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
# template example(context)
	&lt;#context.propertyDisplayer value="..." name="..." /&gt;
# /template

# template JSONProperty(value, name)
	{name}: {value}
# /template

# template HTMLAttribute(name, value)
	{name} = {value}
# /template

var context = {propertyDisplayer: JSONProperty}

example(context);
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="component">
			Component - Statement
		</h3>
<p>
	<p>A component is a template associated to a controller.</p>
		
</p>
<p>
	<p>Syntax: <code># template name using ref:Class</code></p>
		<p>The difference with other templates is that it doesn&#39;t declare input arguments, but rather a class to use as controller, and a name to reference the latter&#39;s instance when the template itself is instantiated.</p>
		<p>When the template is instantiated, a new instance of its controller is created too and bound to the given variable name which is available in the scope of the template. When instantiating its controller, the template calls its <code>init</code> method after all its internal processing (like handling the input parameters, creating the associated attributes, etc).</p>
		<p>Even though the template doesn&#39;t declare its list of input arguments, in fact it takes <code>a single argument</code> which is an object whose properties must correspond to the attributes defined in the controller&#39;s class. Note that if you instantiate the template using the subtemplate statement, this object is automatically built from the specified attributes.</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
var klass = require("hsp/klass");

var Controller = klass({
	attributes: {
		text: {type: "string", defaultValue: "", binding: "none"}
	}
});

# template sub using controller:Controller
	{controller.text}
# /template

# template example using controller:Controller
	{controller.text}&lt;br/&gt;
	&lt;#sub text="Instantiated with statement"/&gt;
# /template

example({text: "Instantiated with API"});
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="controller">
			Controller - Core
		</h3>
<p>
	<p>A controller is a class with specificities used by templates.</p>
		
</p>
<p>
	<p>Controllers are aimed to be used together with templates.</p>
		<p>A controller is a class, which means a set of methods and attributes, and the concept of instances</p>
		<p>Features:</p>
		<ul>
		<li>attributes<ul>
		<li>typing</li>
		<li>binding: 1 way = out (template) -&gt; in (controller), 2 way = the other way too</li>
		<li>default values</li>
		<li><code>on[Attribute]Change</code></li>
		</ul>
		</li>
		<li><code>init</code></li>
		<li><code>dispose</code></li>
		</ul>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
var klass = require("hsp/klass");



var Controller = klass({
	attributes: {
		text: {type: "string", defaultValue: "", binding: "none"},
		number: {type: "int", defaultValue: 0, binding: "1-way"},
		bool: {type: "bool", defaultValue: false, binding: "2-way"}
	},

	init: function() {

	},

	dispose: function() {

	}
});
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="callback">
			callback - Type
		</h3>
<p>
	
</p>
<p>
	
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>

		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="template">
			template - Type
		</h3>
<p>
	
</p>
<p>
	<p>Attributes with type <code>template</code> expect to receive a template source as a value, therefore a string. The latter will be automatically compiled, and then one will be able to use the attribute to reference the generated template - as any other reference to a template.</p>
		<p>Like any other attribute, its value can be passed using the standard ways (subtemplate attribute or <code>render</code> API).</p>
		<p>However there are additional ways to pass this value, closer to the HTML style using the block form of the subtemplate statement.</p>
		<p>Using this form, you can specify each template attribute&#39;s value with the special <em>attribute</em> statement: <code>&lt;@attr&gt; ... &lt;/@attr&gt;</code>.</p>
		<p>Otherwise you can directly insert the template&#39;s content, without naming explicitly any attribute. The attribute receiving the value will be the one defined with an additional property <code>defaultContent</code> set to <code>true</code>, or if there is only one attribute defined with the type <code>template</code>, it will receive it.</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
var Controller = klass({
	attributes: {
		"head":{type:"template"},
		"body":{type:"template", defaultContent:true}
	}
});



# template panel using controller:Controller
  &lt;#controller.head/&gt;
  &lt;#controller.body/&gt;
# /template

# template example()
	&lt;#panel body="..."/&gt;

	&lt;#panel head="..."&gt;
		{m.text}! &lt;a onclick="{update(1)}"&gt;Update model&lt;/a&gt;
	&lt;/#panel&gt;

	&lt;#panel&gt;
		&lt;@head&gt;Panel C: &lt;a onclick="{update(10)}"&gt;Update model&lt;/a&gt;&lt;/@head&gt;
		&lt;@body&gt;{m.text}! &lt;a onclick="{update(100)}"&gt;Update model&lt;/a&gt;&lt;/@body&gt;
	&lt;/#panel&gt;
# /template
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="event-handlers">
			Event handlers - Expression
		</h3>
<p>
	<p>You can use function expressions inside DOM elements&#39; event handlers definitions.</p>
		
</p>
<p>
	<p>This means that instead of giving a piece of JavaScript code to be executed in the global scope, you can use the standard call mechanisms, in the scope of the current module (file).</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>

		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="conditions">
			conditions - Statement
		</h3>
<p>
	<p>You can conditionally execute parts of the template using either <code>{if}/{else if}/{else}</code> statements, or using a ternary expression.</p>
		
</p>
<p>
	
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
# template example(context)
	Number is:
	{if context.number &lt; 0}
		negative
	{else if context.number &gt; 0}
		positive
	{else}
		null
	{/if}
	&nbsp;({context.number === 0 ? 'null' : context.number}).
# /template
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="loop-over-an-array">
			Loop over an array - Statement
		</h3>
<p>
	<p>Use the <code>{foreach value in array}</code> or <code>{foreach index, value in array}</code> expression to loop over an array.</p>
		
</p>
<p>
	<p>Note that each iteration creates a new scope with the current value and possible index.</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
# template example(array)
	&lt;ul&gt;
	{foreach index, value in array}
		&lt;li onclick="{process(value)}"&gt;{index}: {value}&lt;/li&gt;
	{/foreach}
	&lt;/ul&gt;
# /template
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="array-update">
			Array update - Core
		</h3>
<p>
	<p>Standard Array methods trigger the data-binding mechanisms.</p>
		
</p>
<p>
	<p>The following standard methods of Array&#39;s prototype have been overridden for this purpose: <code>splice</code>, <code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>, <code>reverse</code>, <code>sort</code>.</p>
		<p>In addition to those methods, one more has been added: <code>splice2</code>, see corresponding section for more information.</p>
		<p>This means that listeners added on the array will be notified about the changes.</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
var actions = [
	{method: push, label: 'Push'},
	{method: pop, label: 'Pop'},
	{method: unshift, label: 'Unshift'},
	{method: shift, label: 'Shift'},
	{method: reverse, label: 'Reverse'},
	{method: sort, label: 'Sort'},
	{method: splice, label: 'Splice'},
	{method: splice2, label: 'Splice (2)'}
]

var array = [];



# template example(array, actions)
	{foreach action in actions}
		— &lt;a onclick="{action.method()}"&gt;{action.label}&lt;/a&gt;&nbsp;
	{/foreach}
	—

	&lt;br/&gt;

	&lt;ul&gt;
	{foreach value in array}
		&lt;li&gt;{value}&lt;/li&gt;
	{/foreach}
	&lt;/ul&gt;
#/template

example(array, actions).render("output");


function push() {array.push('pushed');}
function pop() {array.pop();}

function unshift() {array.unshift('unshift');}
function shift() {array.shift();}

function reverse() {array.reverse();}
function sort() {
	array.sort(function(a, b) {
		if (a &lt; b) return -1;
		if (a &gt; b) return 1;
		return 0;
	});
}

function splice() {array.splice(1, 0, 'spliced-1', 'spliced-2');}
function splice2() {array.splice2(1, 0, ['spliced2-1', 'spliced2-2'])}
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="array_prototype_splice__index_-howmany_-elements_">
			Array.prototype.splice2(index, howMany, elements) - Core
		</h3>
<p>
	<p>Equivalent of standard <code>splice</code> but using a list of items instead of relying on the variable length of the arguments list.</p>
		
</p>
<p>
	<p>This method triggers the data-binding mechanisms.</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
var array = ['a', 'b', 'e', 'f'];
array.splice2(2, 0, ['c', 'd']); // =&gt; ['a', 'b', 'c', 'd', 'e', 'f']
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="log">
			Log - Core
		</h3>
<p>
	<p>A logging utility.</p>
		
</p>
<p>
	<p>How does logging works?</p>
		<p>First, attach loggers with <code>log.addLogger(callback)</code>: they will receive the log entries when they are pushed.</p>
		<p>Then, to create and push a log entry, you can use one of the logging methods or the <code>{log}</code> statement which works the same but sets itself more contextual information.</p>
		<p>Note that there is a specific logger built in the engine itself, which will also receive the entries that are pushed after all the other (user) loggers have processed. However if one of the latter returns <code>false</code>, this will be skipped.</p>
		<p>Here are the properties of a log entry:</p>
		<ul>
		<li><p><code>type</code>: <code>{String}</code></p>
		<p>The level of the log, that you can use to filter the entries. Will always be one of: <code>&quot;info&quot;</code>, <code>&quot;error&quot;</code>, <code>&quot;warning&quot;</code> or <code>&quot;debug&quot;</code>.</p>
		</li>
		<li><p><code>message</code>: <code>{String}</code></p>
		<p>The message of the log.</p>
		</li>
		<li><p><code>id</code>: <code>{String|Number}</code></p>
		<p>You can use it to identify your entries.</p>
		</li>
		<li><p><code>file</code>: <code>{String}</code></p>
		<p>The name of the file where the entry was issued.</p>
		</li>
		<li><p><code>dir</code>: <code>{String}</code></p>
		<p>The name of the directory containing the previously mentioned file.</p>
		</li>
		<li><p><code>code</code>: <code>{String}</code></p>
		<p>You can use it to specify a piece of code illustrating your message.</p>
		</li>
		<li><p><code>line</code>: <code>{Number}</code></p>
		<p>The line number associated to the entry; usually it corresponds to where you pushed the entry.</p>
		</li>
		<li><p><code>column</code>: <code>{Number}</code></p>
		<p>The column number associated to the entry inside the previously mentioned line.</p>
		</li>
		</ul>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
var log = require("hsp/rt/log");
var myLoggingutility = require("./logging");

log.addLogger(function(message, metadata) {
	myLoggingutility.add({message: message, level: metadata.type});
	return false;
});

log("Here is my first log.")
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="log_addlogger_handler_">
			log.addLogger(handler) - Core
		</h3>
<p>
	<p>Adds a logger to the logging utility.</p>
		
</p>
<p>
	<p>The <code>handler</code> is a function receiving the log entry.</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>

		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="_log_">
			{log} - Statement
		</h3>
<p>
	<p><code>{log param1, param2, ...}</code> will log the given parameters.</p>
		
</p>
<p>
	<p>As for other statements, its parameters are watched, so that a new entry will be issued anytime one of these parameters changes.</p>
		<p>Apart form that, the log statement relies on the available logging methods. It will forward all the given parameters, and add its own metadata with the following values:</p>
		<ul>
		<li><p><code>type</code>:</p>
		<p><code>&quot;debug&quot;</code></p>
		</li>
		<li><p><code>file</code>:</p>
		<p>the file name in which the statement is used</p>
		</li>
		<li><p><code>dir</code>:</p>
		<p>the path of the directory in which the file is</p>
		</li>
		<li><p><code>line</code>:</p>
		<p>the line number in which the statement appears in the file</p>
		</li>
		<li><p><code>column</code>:</p>
		<p>the column number in which the statement appears on the line</p>
		</li>
		</ul>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
# template example()
	{log scope}
# /template
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="log_object___-__-metadata__">
			log(object... [, metaData)] - Core
		</h3>
<p>
	<p>Logs data with <code>debug</code> level.</p>
		
</p>
<p>
	<p>Creates and pushes a log entry.</p>
		<p>It takes two types of arguments:</p>
		<ul>
		<li>A variable list of any kind of object: each will be converted to a string and then they will all be concatenated using a single white space. Finally, this will be used as the value for the <code>message</code> property of the entry.</li>
		<li>An optional set of metadata that mainly matches the properties of the created entry (see below).</li>
		</ul>
		<p>The last argument will be interpreted as the metadata only if:</p>
		<ol>
		<li>it is not the first argument and</li>
		<li>it is an object,</li>
		<li>which contains a property <code>type</code>,</li>
		<li>whose value exactly corresponds to one of those we can find in entries&#39; <code>type</code> property</li>
		</ol>
		<p>Here are the properties of the metadata object and how they are used to build the log entry:</p>
		<ul>
		<li><p><code>type</code>: <code>{String|Number}</code></p>
		<p>Will set the <code>type</code> of the entry, and by definition will always be one of the accepted types.</p>
		</li>
		<li><p><code>id</code>:</p>
		<p>sets the <code>id</code> property of the entry.</p>
		</li>
		<li><p><code>file</code>:</p>
		<p>sets the <code>file</code> property of the entry.</p>
		</li>
		<li><p><code>dir</code>:</p>
		<p>sets the <code>dir</code> property of the entry.</p>
		</li>
		<li><p><code>code</code>:</p>
		<p>sets the <code>code</code> property of the entry.</p>
		</li>
		<li><p><code>line</code>:</p>
		<p>sets the <code>line</code> property of the entry.</p>
		</li>
		<li><p><code>column</code>:</p>
		<p>sets the <code>column</code> property of the entry.</p>
		</li>
		</ul>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
log("message");
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="_let_">
			{let} - Statement
		</h3>
<p>
	<p>Creates local variables in the current scope. Multiple variables can be declared, and they can be initialized too.</p>
		
</p>
<p>
	<p>The scope is associated to a container block, and the latter can be:</p>
		<ul>
		<li>template blocks</li>
		<li>html block elements</li>
		<li>condition blocks: <code>{if}</code>, <code>{else if}</code> or <code>{else}</code></li>
		<li><code>{foreach}</code> block</li>
		</ul>
		<p><code>{let}</code> statements <strong>MUST</strong> appear at the beginning of the blocks where they are used!</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
# template example()
	{let templateLevel}

	&lt;div&gt;
		{let htmlLevel1 = "htmlLevel1Value", htmlLevel2}
	&lt;/div&gt;

	{if condition}
		{let ifLevel}
	{else if condition2}
		{let elseIfLevel}
	{else}
		{let elseLevel}
	{/if}

	{foreach value in container}
		{let foreachLevel}
	{/foreach}
# /template
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="inputs">
			inputs - HTML
		</h3>
<p>
	<p>Input with value synchronization.</p>
		
</p>
<p>
	<p>You can define input elements as you would do in pure HTML.</p>
		<p>As for other elements inside a template, inputs support expressions for all their attributes, and thus binding.</p>
		<p>The interesting thing is that if such an expression is used to define the <code>value</code> attribute of the input, this value will be synchronized with the data model (classical binding).</p>
		<p>This synchronization is done one the <code>keyup</code> event.</p>
		<p>The attribute <code>model</code> can be used instead of <code>value</code>. This has been introduced to enhance the capability of some specific inputs (for details, see sections below).</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
&lt;input type="text" value="{data.text}" /&gt;
&lt;input type="text" model="{data.text}" /&gt;
		</code></pre>
	</p>
</section>
<hr />
	<section>
		<h3 id="radio-input">
			radio input - HTML
		</h3>
<p>
	<p>Define radio button inputs, with automatic grouping.</p>
		
</p>
<p>
	<p>Radio buttons are special since they behave as a group of values where only one is selected at a time.</p>
		<p>Indeed, a radio button alone holds both a selected state and a value.</p>
		<p>A group of radio buttons on its hand will have a single value, corresponding to its currently selected one. But they all aim at setting the <strong>same property of the same model</strong>.</p>
		<p>That&#39;s why we introduced an additional attribute, called <code>model</code>, which will contain the expression referencing the property of the model to bind. This property will receive the value specified in the attribute <code>value</code> of the currently selected radio button.</p>
		<p>Since a group of radio buttons is naturally identified by the fact that they all reference the same property of the model, groups will automatically be built regarding the value of the <code>model</code> attribute.</p>
		
</p>
	<p>
		<strong><em>Example:</em></strong>
		<pre class="hashspace"><code>
&lt;input type="radio" model="{data.value}" value="first" /&gt;
&lt;input type="radio" model="{data.value}" value="second" /&gt;
&lt;input type="radio" model="{data.value}" value="third" /&gt;
		</code></pre>
	</p>
</section>
</body>
</html>