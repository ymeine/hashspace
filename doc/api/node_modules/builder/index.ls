require! {
	fs
	pathlib: path
}

{
	readdirSync:readdir
	readFileSync: readFile
	statSync: stat
} = fs

{join} = pathlib

read = readFile _, 'utf-8'
readJSON = (name) -> JSON.parse read "#name.json"



walk = (dirpath, cb) ->
	dirnames = []
	filenames = []

	for node in readdir(dirpath)
		nodestat = stat(join(dirpath, node))
		category = if nodestat.isDirectory! => dirnames else filenames
		category.push node

	cb {
		dirpath
		dirnames
		filenames
	}

	for directory in dirnames => walk(join(dirpath, directory), cb)


class Section
	(spec) -> @ <<< spec

	toMarkdown: ->
		{title, catchPhrase, description, example} = @

		parts = []

		parts.push """
			----

			### #title

		"""

		if catchPhrase? => parts.push """
			#catchPhrase

		"""

		if description? => parts.push """
			#description

		"""

		parts.push """
			___Example:___

			```hashspace
			#example
			```
		"""

		parts.join '\n'


getSections = (root) ->
	sections = []

	walk root, ({dirpath, dirnames, filenames}) ->
		if filenames.length > 0 and dirnames.length is 0
			meta = readJSON join(dirpath, 'meta')

			description = if 'desc.md' in filenames
				read join(dirpath, 'desc.md')
			else void

			example = read join(dirpath, 'ex.hsp')

			sample = if 'sample.hsp' in filenames
				read join(dirpath, 'sample.hsp')
			else void

			sections.push(new Section({
				meta.title
				meta.catchPhrase

				description
				example
				sample
			}))

	sections



export toMarkdown = (root) -> [section.toMarkdown! for section in getSections root] * '\n\n'
